"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GoogleSignin = void 0;
const react_native_1 = require("react-native");
const NativeGoogleSignin_1 = require("../spec/NativeGoogleSignin");
let configPromise = Promise.resolve();
function configure(options = {}) {
    if (options.offlineAccess && !options.webClientId) {
        throw new Error('RNGoogleSignin: offline use requires server web ClientID');
    }
    configPromise = NativeGoogleSignin_1.NativeModule.configure(options);
}
async function signIn(options = {}) {
    await configPromise;
    return (await NativeGoogleSignin_1.NativeModule.signIn(options));
}
async function hasPlayServices(options = { showPlayServicesUpdateDialog: true }) {
    if (react_native_1.Platform.OS === 'ios') {
        return true;
    }
    else {
        if (options && options.showPlayServicesUpdateDialog === undefined) {
            throw new Error('RNGoogleSignin: Missing property `showPlayServicesUpdateDialog` in options object for `hasPlayServices`');
        }
        return NativeGoogleSignin_1.NativeModule.playServicesAvailable(options.showPlayServicesUpdateDialog);
    }
}
async function addScopes(options) {
    if (react_native_1.Platform.OS === 'ios') {
        return NativeGoogleSignin_1.NativeModule.addScopes(options);
    }
    else {
        const hasUser = await NativeGoogleSignin_1.NativeModule.addScopes(options);
        if (!hasUser) {
            return null;
        }
        // on Android, the user returned in onActivityResult() will contain only the scopes added, not the ones present previously
        // we work around it by calling signInSilently() which returns the user object with all scopes
        return signInSilently();
    }
}
async function signInSilently() {
    await configPromise;
    return NativeGoogleSignin_1.NativeModule.signInSilently();
}
async function signOut() {
    return NativeGoogleSignin_1.NativeModule.signOut();
}
async function revokeAccess() {
    return NativeGoogleSignin_1.NativeModule.revokeAccess();
}
function hasPreviousSignIn() {
    return NativeGoogleSignin_1.NativeModule.hasPreviousSignIn();
}
function getCurrentUser() {
    return NativeGoogleSignin_1.NativeModule.getCurrentUser();
}
async function clearCachedAccessToken(tokenString) {
    if (!tokenString || typeof tokenString !== 'string') {
        return Promise.reject('GoogleSignIn: clearCachedAccessToken() expects a string token.');
    }
    return react_native_1.Platform.OS === 'ios'
        ? null
        : NativeGoogleSignin_1.NativeModule.clearCachedAccessToken(tokenString);
}
async function getTokens() {
    if (react_native_1.Platform.OS === 'ios') {
        return NativeGoogleSignin_1.NativeModule.getTokens();
    }
    else {
        const userObject = await NativeGoogleSignin_1.NativeModule.getTokens();
        return {
            idToken: userObject.idToken,
            accessToken: userObject.accessToken,
        };
    }
}
/**
 * The entry point of the Google Sign In API, exposed as `GoogleSignin`.
 * @group Original Google sign in
 * */
exports.GoogleSignin = {
    hasPlayServices,
    configure,
    signIn,
    addScopes,
    signInSilently,
    signOut,
    revokeAccess,
    hasPreviousSignIn,
    getCurrentUser,
    clearCachedAccessToken,
    getTokens,
};
